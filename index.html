<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pacman для iPhone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            /* Добавлены оптимизации для мобильных */
            -webkit-font-smoothing: antialiased;
            -moz-osx-font-smoothing: grayscale;
        }
        #game {
            display: block;
            margin: 0 auto;
            background: #000;
            /* Оптимизация рендеринга для мобильных */
            -webkit-transform: translateZ(0);
            -webkit-backface-visibility: hidden;
            -webkit-perspective: 1000;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            text-align: center;
            /* Оптимизация композитинга */
            -webkit-transform: translateZ(0);
            will-change: transform;
        }
        .btn {
            width: 80px;
            height: 80px;
            margin: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 32px;
            user-select: none;
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
            /* Оптимизации для сенсорных кнопок */
            -webkit-tap-highlight-color: transparent;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            -webkit-transform: translateZ(0);
            will-change: transform;
        }
        /* --- Стили для стартового экрана --- */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            flex-direction: column;
            /* Оптимизации для стартового экрана */
            -webkit-transform: translateZ(0);
            will-change: transform;
        }
        #startButton {
            padding: 15px 30px;
            font-size: 20px;
            background: yellow;
            color: black;
            border: none;
            border-radius: 10px;
            cursor: pointer;
            /* Оптимизации для кнопки */
            -webkit-appearance: none;
            -webkit-transform: translateZ(0);
            will-change: transform;
        }
        #startButton:hover {
             background: #ffcc00;
        }
        #startScreen h1 {
            color: yellow;
            font-family: Arial, sans-serif;
            margin-bottom: 20px;
        }
        #startScreen p {
            color: white;
            font-family: Arial, sans-serif;
            margin-top: 20px;
            text-align: center;
            padding: 0 20px;
        }
        /* --- Конец стилей для стартового экрана --- */
    </style>
</head>
<body>
    <!-- --- Стартовый экран --- -->
    <div id="startScreen">
        <h1>PACMAN</h1>
        <button id="startButton">Включить звук и Играть</button>
        <p>Нажмите кнопку выше, чтобы включить звук<br>и начать игру</p>
    </div>
    <!-- --- Конец стартового экрана --- -->

    <canvas id="game"></canvas>
    <div id="controls">
        <div class="btn" id="up">↑</div><br>
        <div class="btn" id="left">←</div>
        <div class="btn" id="down">↓</div>
        <div class="btn" id="right">→</div>
    </div>
    <script>
        // Настройки игры
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', { alpha: false }); // Отключаем альфа-канал для лучшей производительности
        const tileSize = 20;
        const pacmanSpeed = 3;
        const ghostSpeed = 2;
        
        // --- Инициализация всех аудио ---
        const backgroundMusic = new Audio('background.mp3');
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.3;
        const dotSound = new Audio('dot.mp3');
        dotSound.volume = 0.5;
        const energizerSound = new Audio('energizer.mp3');
        energizerSound.volume = 0.7;
        const eatGhostSound = new Audio('eat_ghost.mp3');
        eatGhostSound.volume = 0.8;
        const deathSound = new Audio('death.mp3');
        deathSound.volume = 0.8;
        
        // --- Конец инициализации аудио ---
        // --- Функция для попытки начальной инициализации ВСЕХ звуков ---
        let audioUnlocked = false;
        function unlockAudio() {
            if (audioUnlocked) return Promise.resolve();
            console.log("Попытка разблокировки аудио...");
            const promises = [
                backgroundMusic.play().catch(e => {
                    console.log("Фоновая музыка: play не удался, пытаемся load", e.message);
                    backgroundMusic.load();
                }),
                dotSound.play().then(() => { dotSound.pause(); dotSound.currentTime = 0; }).catch(e => {
                    console.log("Звук точки: play/pause не удался, пытаемся load", e.message);
                    dotSound.load();
                }),
                energizerSound.play().then(() => { energizerSound.pause(); energizerSound.currentTime = 0; }).catch(e => {
                    console.log("Звук энерджайзера: play/pause не удался, пытаемся load", e.message);
                    energizerSound.load();
                }),
                eatGhostSound.play().then(() => { eatGhostSound.pause(); eatGhostSound.currentTime = 0; }).catch(e => {
                    console.log("Звук поедания призрака: play/pause не удался, пытаемся load", e.message);
                    eatGhostSound.load();
                }),
                deathSound.play().then(() => { deathSound.pause(); deathSound.currentTime = 0; }).catch(e => {
                    console.log("Звук смерти: play/pause не удался, пытаемся load", e.message);
                    deathSound.load();
                })
            ];
            return Promise.all(promises)
                .then(() => {
                    audioUnlocked = true;
                    console.log("Аудио успешно разблокировано. Звуки должны работать.");
                    backgroundMusic.play().catch(e => console.log("Не удалось запустить фоновую музыку после разблокировки:", e.message));
                    return true;
                })
                .catch(e => {
                    console.error("Ошибка при разблокировке аудио:", e);
                    audioUnlocked = true;
                    return false;
                });
        }
        
        // --- Вспомогательная функция для воспроизведения звука ---
        function playSound(sound) {
             if (!audioUnlocked) {
                 console.warn("Попытка воспроизвести звук до разблокировки:", sound.src || sound);
                 return;
             }
             try {
                 sound.currentTime = 0;
                 const playPromise = sound.play();
                 if (playPromise !== undefined) {
                     playPromise.catch(e => console.error("Ошибка воспроизведения звука (" + (sound.src || "unknown") + "):", e));
                 }
             } catch (e) {
                 console.error("Ошибка воспроизведения звука (в catch) (" + (sound.src || "unknown") + "):", e);
             }
        }
        
        // --- Конец вспомогательной функции ---
        // Подгоняем размер под экран
        function resize() {
            const size = Math.min(window.innerWidth, window.innerHeight - 100);
            canvas.width = 380;
            canvas.height = 420;
            canvas.style.width = size + 'px';
            canvas.style.height = (size * 420/380) + 'px';
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Лабиринт (1 - стена, 0 - дорога, 2 - точки, 3 - энерджайзер)
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,3,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,1,1],
            [0,0,0,1,2,1,2,2,2,2,2,2,2,1,2,1,0,0,0],
            [1,1,1,1,2,1,2,1,1,0,1,1,2,1,2,1,1,1,1],
            [2,2,2,2,2,2,2,1,0,0,0,1,2,2,2,2,2,2,2],
            [1,1,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,1,1],
            [0,0,0,1,2,1,2,2,2,2,2,2,2,1,2,1,0,0,0],
            [1,1,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,3,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,3,1],
            [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        
        // Игровые объекты
        let pacman = {
            x: 9 * tileSize,
            y: 15 * tileSize,
            dx: 0,
            dy: 0,
            radius: tileSize / 2,
            lives: 3
        };
        
        // Создаем объекты Image для спрайтов точек
        const dotImage = new Image();
        dotImage.src = 'dot.png';
        const energizerImage = new Image();
        energizerImage.src = 'energizer.png';
        
        // Создаем объекты Image для Пакмана
        const pacmanImage = new Image();
        pacmanImage.src = 'mypacman.png';
        const pacmanScaredImage = new Image();
        pacmanScaredImage.src = 'mypacman_scared.png';
        const pacmanHealthImage = new Image();
        pacmanHealthImage.src = 'mypacman_health.png';
        
        // Создаем объекты Image для призраков
        const ghostImages = {
            // Нормальные состояния
            red: new Image(),
            cyan: new Image(),
            orange: new Image(),
            // Испуганные состояния (уникальные для каждого призрака)
            red_scared: new Image(),
            cyan_scared: new Image(),
            orange_scared: new Image()
        };
        
        // Загружаем изображения
        ghostImages.red.src = 'ghost_red.png';
        ghostImages.cyan.src = 'ghost_cyan.png';
        ghostImages.orange.src = 'ghost_orange.png';
        ghostImages.red_scared.src = 'ghost_red_scared.png';
        ghostImages.cyan_scared.src = 'ghost_cyan_scared.png';
        ghostImages.orange_scared.src = 'ghost_orange_scared.png';
        
        // Убрали pink призрака, теперь их 3
        let ghosts = [
            { x: 9 * tileSize, y: 8 * tileSize, dx: ghostSpeed, dy: 0, color: 'red', radius: tileSize / 2, imageKey: 'red' },
            { x: 8 * tileSize, y: 9 * tileSize, dx: 0, dy: ghostSpeed, color: 'cyan', radius: tileSize / 2, imageKey: 'cyan' },
            { x: 10 * tileSize, y: 9 * tileSize, dx: 0, dy: -ghostSpeed, color: 'orange', radius: tileSize / 2, imageKey: 'orange' }
        ];
        
        let dots = [];
        let score = 0;
        let scaredGhosts = false;
        let scaredTimer = 0;
        
        // Инициализация точек
        function initDots() {
            dots = [];
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 2) {
                        dots.push({x: x * tileSize + tileSize/2, y: y * tileSize + tileSize/2, big: false});
                    } else if (maze[y][x] === 3) {
                        dots.push({x: x * tileSize + tileSize/2, y: y * tileSize + tileSize/2, big: true});
                    }
                }
            }
        }
        initDots();
        
        // --- Обработчики управления с вызовом unlockAudio ---
        async function handleUserAction(actionFn) {
            if (!audioUnlocked) {
                await unlockAudio();
            }
            actionFn();
        }
        
        // Управление с кнопок
        document.getElementById('up').addEventListener('touchstart', (e) => {
            e.preventDefault(); // Предотвращаем двойное срабатывание
            handleUserAction(() => movePacman(0, -1));
        });
        document.getElementById('down').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleUserAction(() => movePacman(0, 1));
        });
        document.getElementById('left').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleUserAction(() => movePacman(-1, 0));
        });
        document.getElementById('right').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleUserAction(() => movePacman(1, 0));
        });
        
        // Управление с клавиатуры (для тестирования на ПК)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') handleUserAction(() => movePacman(0, -1));
            if (e.key === 'ArrowDown') handleUserAction(() => movePacman(0, 1));
            if (e.key === 'ArrowLeft') handleUserAction(() => movePacman(-1, 0));
            if (e.key === 'ArrowRight') handleUserAction(() => movePacman(1, 0));
        });
        
        // --- Конец обработчиков ---
        function movePacman(dx, dy) {
            pacman.dx = dx * pacmanSpeed;
            pacman.dy = dy * pacmanSpeed;
        }
        
        // Проверка столкновений со стенами
        function checkCollision(x, y) {
            const tileX = Math.floor(x / tileSize);
            const tileY = Math.floor(y / tileSize);
            if (tileX < 0 || tileY < 0 || tileY >= maze.length || tileX >= maze[tileY].length) {
                return true;
            }
            return maze[tileY][tileX] === 1;
        }
        
        // Сбор точек
        function collectDots() {
            for (let i = 0; i < dots.length; i++) {
                const dot = dots[i];
                const dist = Math.sqrt(Math.pow(pacman.x - dot.x, 2) + Math.pow(pacman.y - dot.y, 2));
                if (dist < pacman.radius) {
                    score += dot.big ? 50 : 10;
                    if (dot.big) {
                        scaredGhosts = true;
                        scaredTimer = 500;
                        playSound(energizerSound);
                    } else {
                        playSound(dotSound);
                    }
                    dots.splice(i, 1);
                    break;
                }
            }
        }
        
        // Телепортация через туннели
        function checkTunnels(obj) {
            if (obj.x < -obj.radius) {
                obj.x = canvas.width + obj.radius;
            } else if (obj.x > canvas.width + obj.radius) {
                obj.x = -obj.radius;
            }
        }
        
        // ИИ призраков
        function updateGhosts() {
            if (scaredTimer > 0) {
                scaredTimer--;
            } else {
                scaredGhosts = false;
            }
            ghosts.forEach(ghost => {
                const directions = [];
                if (!checkCollision(ghost.x, ghost.y - ghostSpeed)) directions.push({dx: 0, dy: -ghostSpeed});
                if (!checkCollision(ghost.x, ghost.y + ghostSpeed)) directions.push({dx: 0, dy: ghostSpeed});
                if (!checkCollision(ghost.x - ghostSpeed, ghost.y)) directions.push({dx: -ghostSpeed, dy: 0});
                if (!checkCollision(ghost.x + ghostSpeed, ghost.y)) directions.push({dx: ghostSpeed, dy: 0});
                if (directions.length > 0 && (Math.random() < 0.05 ||
                    checkCollision(ghost.x + ghost.dx, ghost.y + ghost.dy))) {
                    const newDir = directions[Math.floor(Math.random() * directions.length)];
                    ghost.dx = newDir.dx;
                    ghost.dy = newDir.dy;
                }
                ghost.x += ghost.dx;
                ghost.y += ghost.dy;
                checkTunnels(ghost);
                // Проверка столкновения с Пакманом
                const dist = Math.sqrt(Math.pow(pacman.x - ghost.x, 2) + Math.pow(pacman.y - ghost.y, 2));
                if (dist < pacman.radius + ghost.radius) {
                    if (scaredGhosts) {
                        ghost.x = 9 * tileSize;
                        ghost.y = 8 * tileSize;
                        score += 200;
                        playSound(eatGhostSound);
                    } else {
                        pacman.lives--;
                        playSound(deathSound);
                        resetPositions();
                    }
                }
            });
        }
        
        function resetPositions() {
            pacman.x = 9 * tileSize;
            pacman.y = 15 * tileSize;
            pacman.dx = 0;
            pacman.dy = 0;
            // Сбрасываем позиции для 3 призраков
            ghosts[0].x = 9 * tileSize; ghosts[0].y = 8 * tileSize;
            ghosts[1].x = 8 * tileSize; ghosts[1].y = 9 * tileSize;
            ghosts[2].x = 10 * tileSize; ghosts[2].y = 9 * tileSize;
        }
        
        // --- Оптимизированный игровой цикл ---
        let lastTime = 0;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        
        function gameLoop(currentTime) {
            // Ограничение FPS для лучшей производительности
            if (currentTime - lastTime < frameInterval) {
                requestAnimationFrame(gameLoop);
                return;
            }
            lastTime = currentTime;
            
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        
        function update() {
            const newX = pacman.x + pacman.dx;
            const newY = pacman.y + pacman.dy;
            if (!checkCollision(newX, pacman.y)) {
                pacman.x = newX;
            }
            if (!checkCollision(pacman.x, newY)) {
                pacman.y = newY;
            }
            checkTunnels(pacman);
            collectDots();
            updateGhosts();
            if (pacman.lives <= 0) {
                alert('Игра окончена! Счёт: ' + score);
                pacman.lives = 3;
                score = 0;
                initDots();
                resetPositions();
            }
            if (dots.length === 0) {
                alert('Победа! Счёт: ' + score);
                score = 0;
                initDots();
                resetPositions();
            }
        }
        
        function draw() {
            // Очищаем canvas более эффективно
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Рисование лабиринта
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = 'navy';
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }
            
            // Рисование точек
            for (const dot of dots) {
                const dotSize = dot.big ? 12 : 6;
                const useImage = dot.big ? energizerImage : dotImage;

                if (useImage.complete && useImage.naturalWidth !== 0) {
                    ctx.drawImage(
                        useImage,
                        dot.x - dotSize / 2,
                        dot.y - dotSize / 2,
                        dotSize,
                        dotSize
                    );
                } else {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, dot.big ? 6 : 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            
            // Рисование Пакмана из изображения
            let usePacmanImage = pacmanImage;
            if (scaredGhosts) {
                usePacmanImage = pacmanScaredImage;
            }

            if (usePacmanImage.complete && usePacmanImage.naturalWidth !== 0) {
                ctx.drawImage(usePacmanImage, pacman.x - pacman.radius, pacman.y - pacman.radius, pacman.radius * 2, pacman.radius * 2);
            } else {
                 ctx.fillStyle = 'yellow';
                 ctx.beginPath();
                 ctx.arc(pacman.x, pacman.y, pacman.radius, 0, Math.PI * 2);
                 ctx.fill();
            }
            
            // Рисование призраков из изображений
            ghosts.forEach(ghost => {
                let useImageKey;
                if (scaredGhosts) {
                    useImageKey = ghost.imageKey + '_scared';
                } else {
                    useImageKey = ghost.imageKey;
                }
                const useImage = ghostImages[useImageKey];
                if (useImage && useImage.complete && useImage.naturalWidth !== 0) {
                    ctx.drawImage(useImage, ghost.x - ghost.radius, ghost.y - ghost.radius, ghost.radius * 2, ghost.radius * 2);
                } else {
                    ctx.fillStyle = scaredGhosts ? '#0000FF' : ghost.color;
                    ctx.beginPath();
                    ctx.arc(ghost.x, ghost.y - 5, ghost.radius, Math.PI, 0, false);
                    ctx.lineTo(ghost.x + ghost.radius, ghost.y + ghost.radius - 5);
                    for (let i = 0; i < 3; i++) {
                        ctx.lineTo(ghost.x + ghost.radius - (i * 10), ghost.y + ghost.radius - 5 + (i % 2 === 0 ? 5 : 0));
                    }
                    ctx.lineTo(ghost.x - ghost.radius, ghost.y + ghost.radius - 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(ghost.x - 5, ghost.y - 8, 4, 0, Math.PI * 2);
                    ctx.arc(ghost.x + 5, ghost.y - 8, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(ghost.x - 5 + (ghost.dx * 2), ghost.y - 8 + (ghost.dy * 2), 2, 0, Math.PI * 2);
                    ctx.arc(ghost.x + 5 + (ghost.dx * 2), ghost.y - 8 + (ghost.dy * 2), 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            
            // Рисование счёта и жизней
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('Счёт: ' + score, 10, 30);

            for (let i = 0; i < pacman.lives; i++) {
                const lifeX = 10 + i * 25;
                const lifeY = 50;
                const lifeSize = 20;

                if (pacmanHealthImage.complete && pacmanHealthImage.naturalWidth !== 0) {
                    ctx.drawImage(
                        pacmanHealthImage,
                        lifeX - lifeSize / 2,
                        lifeY - lifeSize / 2,
                        lifeSize,
                        lifeSize
                    );
                } else {
                    ctx.fillStyle = 'yellow';
                    ctx.beginPath();
                    ctx.arc(lifeX, lifeY, lifeSize / 2, 0.2, Math.PI * 2 - 0.2);
                    ctx.lineTo(lifeX, lifeY);
                    ctx.fill();
                }
            }
        }

        // Обработчики загрузки для изображений призраков
        Object.keys(ghostImages).forEach(key => {
            const img = ghostImages[key];
            img.onload = function() {
                console.log(`Изображение призрака ${key} загружено.`);
            };
            img.onerror = function() {
                console.error(`Ошибка загрузки изображения ${key}.png.`);
            };
        });

        // Обработчики загрузки для изображений Пакмана
        pacmanImage.onload = function() {
            console.log("Изображение Пакмана (mypacman.png) загружено.");
        };
        pacmanImage.onerror = function() {
            console.error("Ошибка загрузки изображения mypacman.png.");
        };

        pacmanScaredImage.onload = function() {
            console.log("Изображение испуганного Пакмана (mypacman_scared.png) загружено.");
        };
        pacmanScaredImage.onerror = function() {
            console.error("Ошибка загрузки изображения mypacman_scared.png.");
        };

        pacmanHealthImage.onload = function() {
            console.log("Изображение иконки здоровья Пакмана (mypacman_health.png) загружено.");
        };
        pacmanHealthImage.onerror = function() {
            console.error("Ошибка загрузки изображения mypacman_health.png.");
        };

        // Обработчики загрузки для изображений точек
        dotImage.onload = function() {
            console.log("Изображение точки (dot.png) загружено.");
        };
        dotImage.onerror = function() {
            console.error("Ошибка загрузки изображения dot.png.");
        };
        energizerImage.onload = function() {
            console.log("Изображение энерджайзера (energizer.png) загружено.");
        };
        energizerImage.onerror = function() {
            console.error("Ошибка загрузки изображения energizer.png.");
        };

        // Обработка стартовой кнопки
        document.getElementById('startButton').addEventListener('click', async function() {
            console.log("Нажата кнопка 'Включить звук и Играть'");
            document.getElementById('startScreen').style.display = 'none';

            if (!audioUnlocked) {
                try {
                    await unlockAudio();
                    console.log("Аудио разблокировано по кнопке.");
                } catch (e) {
                    console.error("Ошибка при разблокировке аудио по кнопке:", e);
                }
            } else {
                console.log("Аудио уже было разблокировано ранее.");
            }

            if (audioUnlocked) {
                 if (backgroundMusic.paused) {
                     console.log("Принудительный запуск фоновой музыки...");
                     playSound(backgroundMusic);
                 } else {
                     console.log("Фоновая музыка уже играет.");
                 }
            } else {
                console.warn("Аудио не разблокировано, фоновая музыка не будет запущена.");
            }
        });

        // Запускаем игровой цикл с ограничением FPS
        gameLoop();
    </script>
</body>
</html>
