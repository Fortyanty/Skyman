<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pacman для iPhone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }
        #game {
            display: block;
            margin: 0 auto;
            background: #000;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            text-align: center;
        }
        .btn {
            /* Увеличение кнопок */
            width: 80px;
            height: 80px;
            margin: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 32px; /* Увеличение шрифта стрелок */
            user-select: none;
            /* Добавление тени для лучшей видимости */
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        /* --- Стили для стартового экрана --- */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 10;
            flex-direction: column;
        }
        #startButton {
            padding: 15px 30px;
            font-size: 20px;
            background: yellow;
            color: black;
            border: none;
            border-radius: 10px;
            cursor: pointer;
        }
        #startButton:hover {
             background: #ffcc00; /* Немного темнее желтого при наведении */
        }
        #startScreen h1 {
            color: yellow;
            font-family: Arial, sans-serif;
            margin-bottom: 20px;
        }
        #startScreen p {
            color: white;
            font-family: Arial, sans-serif;
            margin-top: 20px;
            text-align: center;
            padding: 0 20px;
        }
        /* --- Конец стилей для стартового экрана --- */
    </style>
</head>
<body>
    <!-- --- Стартовый экран --- -->
    <div id="startScreen">
        <h1>PACMAN</h1>
        <button id="startButton">Включить звук и Играть</button>
        <p>Нажмите кнопку выше, чтобы включить звук<br>и начать игру</p>
    </div>
    <!-- --- Конец стартового экрана --- -->

    <canvas id="game"></canvas>
    <div id="controls">
        <div class="btn" id="up">↑</div><br>
        <div class="btn" id="left">←</div>
        <div class="btn" id="down">↓</div>
        <div class="btn" id="right">→</div>
    </div>
    <script>
        // Настройки игры
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d', { alpha: false }); // Отключаем альфа-канал для лучшей производительности
        const tileSize = 20;
        const pacmanSpeed = 3;
        const ghostSpeed = 2;

        // --- Инициализация Web Audio API ---
        let audioContext;
        let audioUnlocked = false;
        const soundBuffers = {}; // Хранилище для декодированных аудиобуферов

        // --- Функция для инициализации AudioContext ---
        async function initAudio() {
            if (audioContext) return;
            
            try {
                // Создаем AudioContext
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                console.log("AudioContext создан");
                
                // Загружаем и декодируем все аудиофайлы
                const soundFiles = {
                    'background': 'background.mp3',
                    'dot': 'dot.mp3',
                    'energizer': 'energizer.mp3',
                    'eat_ghost': 'eat_ghost.mp3',
                    'death': 'death.mp3'
                };

                const loadPromises = Object.keys(soundFiles).map(async (key) => {
                    try {
                        const response = await fetch(soundFiles[key]);
                        const arrayBuffer = await response.arrayBuffer();
                        soundBuffers[key] = await audioContext.decodeAudioData(arrayBuffer);
                        console.log(`Звук ${key} загружен и декодирован`);
                    } catch (error) {
                        console.error(`Ошибка загрузки/декодирования звука ${key}:`, error);
                    }
                });

                await Promise.all(loadPromises);
                console.log("Все звуки загружены");
                
            } catch (error) {
                console.error("Ошибка инициализации аудиосистемы:", error);
                audioContext = null;
            }
        }

        // --- Функция для воспроизведения звука через Web Audio API ---
        function playSoundWebAudio(soundKey, volume = 1.0) {
            if (!audioContext || !soundBuffers[soundKey] || !audioUnlocked) {
                console.warn(`Невозможно воспроизвести звук ${soundKey}. Аудио не готово.`);
                return;
            }

            try {
                // Создаем новый AudioBufferSourceNode для каждого воспроизведения
                const source = audioContext.createBufferSource();
                source.buffer = soundBuffers[soundKey];
                
                // Создаем узел гейна для управления громкостью
                const gainNode = audioContext.createGain();
                gainNode.gain.value = volume;
                
                // Связываем узлы: источник -> гейн -> выход
                source.connect(gainNode);
                gainNode.connect(audioContext.destination);
                
                // Воспроизводим звук
                source.start(0);
                
                // Очищаем ресурсы после воспроизведения
                source.onended = () => {
                    source.disconnect();
                    gainNode.disconnect();
                };
                
            } catch (error) {
                console.error(`Ошибка воспроизведения звука ${soundKey}:`, error);
            }
        }

        // --- Функция для попытки разблокировки аудио ---
        async function unlockAudio() {
            if (audioUnlocked) return Promise.resolve();
            
            console.log("Попытка разблокировки аудио...");
            
            try {
                // Инициализируем AudioContext и загружаем звуки
                await initAudio();
                
                if (!audioContext) {
                    throw new Error("Не удалось создать AudioContext");
                }
                
                // Воспроизводим короткий тишину для разблокировки
                const silentBuffer = audioContext.createBuffer(1, 1, 22050);
                const source = audioContext.createBufferSource();
                source.buffer = silentBuffer;
                source.connect(audioContext.destination);
                source.start(0);
                
                // Ждем немного и проверяем состояние
                await new Promise(resolve => setTimeout(resolve, 100));
                
                if (audioContext.state === 'running') {
                    audioUnlocked = true;
                    console.log("Аудио успешно разблокировано через Web Audio API.");
                    
                    // Автоматически запускаем фоновую музыку
                    playSoundWebAudio('background', 0.3);
                    return true;
                } else {
                    throw new Error("AudioContext не перешел в состояние 'running'");
                }
                
            } catch (error) {
                console.error("Ошибка при разблокировке аудио:", error);
                audioUnlocked = true; // Даже при ошибке считаем, что попытка была
                return false;
            }
        }

        // --- Вспомогательные функции для воспроизведения конкретных звуков ---
        function playDotSound() {
            playSoundWebAudio('dot', 0.5);
        }
        
        function playEnergizerSound() {
            playSoundWebAudio('energizer', 0.7);
        }
        
        function playEatGhostSound() {
            playSoundWebAudio('eat_ghost', 0.8);
        }
        
        function playDeathSound() {
            playSoundWebAudio('death', 0.8);
        }
        
        function playBackgroundMusic() {
            // Фоновая музыка будет зациклена отдельно
            playSoundWebAudio('background', 0.3);
        }
        // --- Конец вспомогательных функций ---

        // Подгоняем размер под экран
        function resize() {
            const size = Math.min(window.innerWidth, window.innerHeight - 100);
            canvas.width = 380;
            canvas.height = 420;
            canvas.style.width = size + 'px';
            canvas.style.height = (size * 420/380) + 'px';
        }
        resize();
        window.addEventListener('resize', resize);
        
        // Лабиринт (1 - стена, 0 - дорога, 2 - точки, 3 - энерджайзер)
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,3,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,1,1],
            [0,0,0,1,2,1,2,2,2,2,2,2,2,1,2,1,0,0,0],
            [1,1,1,1,2,1,2,1,1,0,1,1,2,1,2,1,1,1,1],
            [2,2,2,2,2,2,2,1,0,0,0,1,2,2,2,2,2,2,2],
            [1,1,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,1,1],
            [0,0,0,1,2,1,2,2,2,2,2,2,2,1,2,1,0,0,0],
            [1,1,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,3,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,3,1],
            [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        // Игровые объекты
        let pacman = {
            x: 9 * tileSize,
            y: 15 * tileSize,
            dx: 0,
            dy: 0,
            radius: tileSize / 2,
            lives: 3
        };
        // Создаем объекты Image для спрайтов точек
        const dotImage = new Image();
        dotImage.src = 'dot.png';
        const energizerImage = new Image();
        energizerImage.src = 'energizer.png';
        // Создаем объекты Image для Пакмана
        const pacmanImage = new Image();
        pacmanImage.src = 'mypacman.png';
        const pacmanScaredImage = new Image();
        pacmanScaredImage.src = 'mypacman_scared.png';
        const pacmanHealthImage = new Image();
        pacmanHealthImage.src = 'mypacman_health.png';
        // Создаем объекты Image для призраков
        const ghostImages = {
            // Нормальные состояния
            red: new Image(),
            cyan: new Image(),
            orange: new Image(),
            // Испуганные состояния (уникальные для каждого призрака)
            red_scared: new Image(),
            cyan_scared: new Image(),
            orange_scared: new Image()
        };
        // Загружаем изображения
        ghostImages.red.src = 'ghost_red.png';
        ghostImages.cyan.src = 'ghost_cyan.png';
        ghostImages.orange.src = 'ghost_orange.png';
        ghostImages.red_scared.src = 'ghost_red_scared.png';
        ghostImages.cyan_scared.src = 'ghost_cyan_scared.png';
        ghostImages.orange_scared.src = 'ghost_orange_scared.png';
        // Убрали pink призрака, теперь их 3
        let ghosts = [
            { x: 9 * tileSize, y: 8 * tileSize, dx: ghostSpeed, dy: 0, color: 'red', radius: tileSize / 2, imageKey: 'red' },
            { x: 8 * tileSize, y: 9 * tileSize, dx: 0, dy: ghostSpeed, color: 'cyan', radius: tileSize / 2, imageKey: 'cyan' },
            { x: 10 * tileSize, y: 9 * tileSize, dx: 0, dy: -ghostSpeed, color: 'orange', radius: tileSize / 2, imageKey: 'orange' }
        ];
        let dots = [];
        let score = 0;
        let scaredGhosts = false;
        let scaredTimer = 0;
        // Инициализация точек
        function initDots() {
            dots = [];
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 2) {
                        dots.push({x: x * tileSize + tileSize/2, y: y * tileSize + tileSize/2, big: false});
                    } else if (maze[y][x] === 3) {
                        dots.push({x: x * tileSize + tileSize/2, y: y * tileSize + tileSize/2, big: true});
                    }
                }
            }
        }
        initDots();
        // --- Обработчики управления с вызовом unlockAudio ---
        async function handleUserAction(actionFn) {
            if (!audioUnlocked) {
                await unlockAudio();
            }
            actionFn();
        }
        // Управление с кнопок
        document.getElementById('up').addEventListener('touchstart', (e) => {
            e.preventDefault(); // Предотвращаем двойное срабатывание
            handleUserAction(() => movePacman(0, -1));
        });
        document.getElementById('down').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleUserAction(() => movePacman(0, 1));
        });
        document.getElementById('left').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleUserAction(() => movePacman(-1, 0));
        });
        document.getElementById('right').addEventListener('touchstart', (e) => {
            e.preventDefault();
            handleUserAction(() => movePacman(1, 0));
        });
        // Управление с клавиатуры (для тестирования на ПК)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') handleUserAction(() => movePacman(0, -1));
            if (e.key === 'ArrowDown') handleUserAction(() => movePacman(0, 1));
            if (e.key === 'ArrowLeft') handleUserAction(() => movePacman(-1, 0));
            if (e.key === 'ArrowRight') handleUserAction(() => movePacman(1, 0));
        });
        // --- Конец обработчиков ---
        function movePacman(dx, dy) {
            pacman.dx = dx * pacmanSpeed;
            pacman.dy = dy * pacmanSpeed;
        }
        // Проверка столкновений со стенами
        function checkCollision(x, y) {
            const tileX = Math.floor(x / tileSize);
            const tileY = Math.floor(y / tileSize);
            if (tileX < 0 || tileY < 0 || tileY >= maze.length || tileX >= maze[tileY].length) {
                return true;
            }
            return maze[tileY][tileX] === 1;
        }
        // Сбор точек
        function collectDots() {
            for (let i = 0; i < dots.length; i++) {
                const dot = dots[i];
                const dist = Math.sqrt(Math.pow(pacman.x - dot.x, 2) + Math.pow(pacman.y - dot.y, 2));
                if (dist < pacman.radius) {
                    score += dot.big ? 50 : 10;
                    if (dot.big) {
                        scaredGhosts = true;
                        scaredTimer = 500;
                        playEnergizerSound(); // Используем новую функцию
                    } else {
                        playDotSound(); // Используем новую функцию
                    }
                    dots.splice(i, 1);
                    break;
                }
            }
        }
        // Телепортация через туннели
        function checkTunnels(obj) {
            if (obj.x < -obj.radius) {
                obj.x = canvas.width + obj.radius;
            } else if (obj.x > canvas.width + obj.radius) {
                obj.x = -obj.radius;
            }
        }
        // ИИ призраков
        function updateGhosts() {
            if (scaredTimer > 0) {
                scaredTimer--;
            } else {
                scaredGhosts = false;
            }
            ghosts.forEach(ghost => {
                const directions = [];
                if (!checkCollision(ghost.x, ghost.y - ghostSpeed)) directions.push({dx: 0, dy: -ghostSpeed});
                if (!checkCollision(ghost.x, ghost.y + ghostSpeed)) directions.push({dx: 0, dy: ghostSpeed});
                if (!checkCollision(ghost.x - ghostSpeed, ghost.y)) directions.push({dx: -ghostSpeed, dy: 0});
                if (!checkCollision(ghost.x + ghostSpeed, ghost.y)) directions.push({dx: ghostSpeed, dy: 0});
                if (directions.length > 0 && (Math.random() < 0.05 ||
                    checkCollision(ghost.x + ghost.dx, ghost.y + ghost.dy))) {
                    const newDir = directions[Math.floor(Math.random() * directions.length)];
                    ghost.dx = newDir.dx;
                    ghost.dy = newDir.dy;
                }
                ghost.x += ghost.dx;
                ghost.y += ghost.dy;
                checkTunnels(ghost);
                // Проверка столкновения с Пакманом
                const dist = Math.sqrt(Math.pow(pacman.x - ghost.x, 2) + Math.pow(pacman.y - ghost.y, 2));
                if (dist < pacman.radius + ghost.radius) {
                    if (scaredGhosts) {
                        ghost.x = 9 * tileSize;
                        ghost.y = 8 * tileSize;
                        score += 200;
                        playEatGhostSound(); // Используем новую функцию
                    } else {
                        pacman.lives--;
                        playDeathSound(); // Используем новую функцию
                        resetPositions();
                    }
                }
            });
        }
        function resetPositions() {
            pacman.x = 9 * tileSize;
            pacman.y = 15 * tileSize;
            pacman.dx = 0;
            pacman.dy = 0;
            // Сбрасываем позиции для 3 призраков
            ghosts[0].x = 9 * tileSize; ghosts[0].y = 8 * tileSize;
            ghosts[1].x = 8 * tileSize; ghosts[1].y = 9 * tileSize;
            ghosts[2].x = 10 * tileSize; ghosts[2].y = 9 * tileSize;
        }
        // --- Оптимизированный игровой цикл ---
        let lastTime = 0;
        const targetFPS = 60;
        const frameInterval = 1000 / targetFPS;
        
        function gameLoop(currentTime) {
            // Ограничение FPS для лучшей производительности
            if (currentTime - lastTime < frameInterval) {
                requestAnimationFrame(gameLoop);
                return;
            }
            lastTime = currentTime;
            
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        function update() {
            const newX = pacman.x + pacman.dx;
            const newY = pacman.y + pacman.dy;
            if (!checkCollision(newX, pacman.y)) {
                pacman.x = newX;
            }
            if (!checkCollision(pacman.x, newY)) {
                pacman.y = newY;
            }
            checkTunnels(pacman);
            collectDots();
            updateGhosts();
            if (pacman.lives <= 0) {
                alert('Игра окончена! Счёт: ' + score);
                pacman.lives = 3;
                score = 0;
                initDots();
                resetPositions();
            }
            if (dots.length === 0) {
                alert('Победа! Счёт: ' + score);
                score = 0;
                initDots();
                resetPositions();
            }
        }
        function draw() {
            // Очищаем canvas более эффективно
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Рисование лабиринта
            ctx.strokeStyle = 'blue';
            ctx.lineWidth = 2;
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1) {
                        ctx.fillStyle = 'navy';
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }
            // Рисование точек
            for (const dot of dots) {
                const dotSize = dot.big ? 12 : 6;
                const useImage = dot.big ? energizerImage : dotImage;

                if (useImage.complete && useImage.naturalWidth !== 0) {
                    ctx.drawImage(
                        useImage,
                        dot.x - dotSize / 2,
                        dot.y - dotSize / 2,
                        dotSize,
                        dotSize
                    );
                } else {
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, dot.big ? 6 : 3, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
            // Рисование Пакмана из изображения
            let usePacmanImage = pacmanImage;
            if (scaredGhosts) {
                usePacmanImage = pacmanScaredImage;
            }

            if (usePacmanImage.complete && usePacmanImage.naturalWidth !== 0) {
                ctx.drawImage(usePacmanImage, pacman.x - pacman.radius, pacman.y - pacman.radius, pacman.radius * 2, pacman.radius * 2);
            } else {
                 ctx.fillStyle = 'yellow';
                 ctx.beginPath();
                 ctx.arc(pacman.x, pacman.y, pacman.radius, 0, Math.PI * 2);
                 ctx.fill();
            }
            // Рисование призраков из изображений
            ghosts.forEach(ghost => {
                let useImageKey;
                if (scaredGhosts) {
                    useImageKey = ghost.imageKey + '_scared';
                } else {
                    useImageKey = ghost.imageKey;
                }
                const useImage = ghostImages[useImageKey];
                if (useImage && useImage.complete && useImage.naturalWidth !== 0) {
                    ctx.drawImage(useImage, ghost.x - ghost.radius, ghost.y - ghost.radius, ghost.radius * 2, ghost.radius * 2);
                } else {
                    ctx.fillStyle = scaredGhosts ? '#0000FF' : ghost.color;
                    ctx.beginPath();
                    ctx.arc(ghost.x, ghost.y - 5, ghost.radius, Math.PI, 0, false);
                    ctx.lineTo(ghost.x + ghost.radius, ghost.y + ghost.radius - 5);
                    for (let i = 0; i < 3; i++) {
                        ctx.lineTo(ghost.x + ghost.radius - (i * 10), ghost.y + ghost.radius - 5 + (i % 2 === 0 ? 5 : 0));
                    }
                    ctx.lineTo(ghost.x - ghost.radius, ghost.y + ghost.radius - 5);
                    ctx.closePath();
                    ctx.fill();
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(ghost.x - 5, ghost.y - 8, 4, 0, Math.PI * 2);
                    ctx.arc(ghost.x + 5, ghost.y - 8, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(ghost.x - 5 + (ghost.dx * 2), ghost.y - 8 + (ghost.dy * 2), 2, 0, Math.PI * 2);
                    ctx.arc(ghost.x + 5 + (ghost.dx * 2), ghost.y - 8 + (ghost.dy * 2), 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });
            // Рисование счёта и жизней
            ctx.fillStyle = 'white';
            ctx.font = '20px Arial';
            ctx.fillText('Счёт: ' + score, 10, 30);

            for (let i = 0; i < pacman.lives; i++) {
                const lifeX = 10 + i * 25;
                const lifeY = 50;
                const lifeSize = 20;

                if (pacmanHealthImage.complete && pacmanHealthImage.naturalWidth !== 0) {
                    ctx.drawImage(
                        pacmanHealthImage,
                        lifeX - lifeSize / 2,
                        lifeY - lifeSize / 2,
                        lifeSize,
                        lifeSize
                    );
                } else {
                    ctx.fillStyle = 'yellow';
                    ctx.beginPath();
                    ctx.arc(lifeX, lifeY, lifeSize / 2, 0.2, Math.PI * 2 - 0.2);
                    ctx.lineTo(lifeX, lifeY);
                    ctx.fill();
                }
            }
        }

        // Обработчики загрузки для изображений призраков
        Object.keys(ghostImages).forEach(key => {
            const img = ghostImages[key];
            img.onload = function() {
                console.log(`Изображение призрака ${key} загружено.`);
            };
            img.onerror = function() {
                console.error(`Ошибка загрузки изображения ${key}.png.`);
            };
        });

        // Обработчики загрузки для изображений Пакмана
        pacmanImage.onload = function() {
            console.log("Изображение Пакмана (mypacman.png) загружено.");
        };
        pacmanImage.onerror = function() {
            console.error("Ошибка загрузки изображения mypacman.png.");
        };

        pacmanScaredImage.onload = function() {
            console.log("Изображение испуганного Пакмана (mypacman_scared.png) загружено.");
        };
        pacmanScaredImage.onerror = function() {
            console.error("Ошибка загрузки изображения mypacman_scared.png.");
        };

        pacmanHealthImage.onload = function() {
            console.log("Изображение иконки здоровья Пакмана (mypacman_health.png) загружено.");
        };
        pacmanHealthImage.onerror = function() {
            console.error("Ошибка загрузки изображения mypacman_health.png.");
        };

        // Обработчики загрузки для изображений точек
        dotImage.onload = function() {
            console.log("Изображение точки (dot.png) загружено.");
        };
        dotImage.onerror = function() {
            console.error("Ошибка загрузки изображения dot.png.");
        };
        energizerImage.onload = function() {
            console.log("Изображение энерджайзера (energizer.png) загружено.");
        };
        energizerImage.onerror = function() {
            console.error("Ошибка загрузки изображения energizer.png.");
        };

        // Обработка стартовой кнопки
        document.getElementById('startButton').addEventListener('click', async function() {
            console.log("Нажата кнопка 'Включить звук и Играть'");
            document.getElementById('startScreen').style.display = 'none';

            if (!audioUnlocked) {
                try {
                    await unlockAudio();
                    console.log("Аудио разблокировано по кнопке.");
                } catch (e) {
                    console.error("Ошибка при разблокировке аудио по кнопке:", e);
                }
            } else {
                console.log("Аудио уже было разблокировано ранее.");
            }
        });

        // Запускаем игровой цикл с ограничением FPS
        gameLoop();
    </script>
</body>
</html>
