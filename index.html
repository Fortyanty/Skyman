<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Pacman для iPhone</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background: #000;
            touch-action: manipulation;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
        }
        #game {
            display: block;
            margin: 0 auto;
            background: #000;
        }
        #controls {
            position: fixed;
            bottom: 20px;
            width: 100%;
            text-align: center;
        }
        .btn {
            /* Увеличение кнопок */
            width: 80px;
            height: 80px;
            margin: 10px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 50%;
            display: inline-flex;
            justify-content: center;
            align-items: center;
            color: white;
            font-size: 32px; /* Увеличение шрифта стрелок */
            user-select: none;
            /* Добавление тени для лучшей видимости */
            box-shadow: 0 0 10px rgba(255, 255, 255, 0.5);
        }
        /* --- Стили для стартового экрана --- */
        #startScreen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: black;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 10;
        }
        #startButton {
            /* Круглая фиолетовая кнопка */
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: purple; /* Фиолетовый цвет */
            color: white;
            font-size: 18px;
            border: 3px solid yellow; /* Желтая рамка для выделения */
            cursor: pointer;
            display: flex;
            justify-content: center;
            align-items: center;
            text-align: center;
            padding: 10px;
            box-sizing: border-box;
            margin: 20px 0; /* Отступы сверху и снизу от кнопки */
            box-shadow: 0 0 15px rgba(255, 255, 0, 0.7); /* Желтая тень */
            transition: background 0.3s, transform 0.2s;
        }
        #startButton:hover {
            background: #9932cc; /* Темнее фиолетовый при наведении */
            transform: scale(1.05); /* Немного увеличиваем при наведении */
        }
        #startButton:active {
             transform: scale(0.98); /* Немного уменьшаем при нажатии */
        }
        /* Контейнер для изображений персонажей */
        .characters-container {
            display: flex;
            justify-content: center;
            align-items: center;
            flex-wrap: wrap; /* Перенос на новую строку при необходимости */
            gap: 20px; /* Расстояние между изображениями */
            max-width: 90%;
            margin-bottom: 20px; /* Отступ снизу от персонажей до кнопки */
        }
        .character-img {
            width: 50px;
            height: 50px;
            /* Если изображения не загрузятся, будет видно цветной кружок */
            background-color: #333;
            border-radius: 50%;
        }
        /* Стили для резервных кружков персонажей */
        .pacman-char { background-color: purple; }
        .ghost-red-char { background-color: red; }
        .ghost-cyan-char { background-color: cyan; }
        .ghost-orange-char { background-color: orange; }
        .dot-char { background-color: white; width: 20px; height: 20px; }
        .energizer-char { background-color: white; width: 30px; height: 30px; }
        /* --- Конец стилей для стартового экрана --- */
    </style>
</head>
<body>
    <!-- --- Стартовый экран --- -->
    <div id="startScreen">
        <!-- Контейнер для изображений персонажей -->
        <div class="characters-container">
            <img class="character-img pacman-char" src="mypacman.png" alt="Pacman" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
            <div class="character-img pacman-char" style="display:none;"></div> <!-- Резервный кружок -->

            <img class="character-img ghost-red-char" src="ghost_red.png" alt="Red Ghost" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
            <div class="character-img ghost-red-char" style="display:none;"></div>

            <img class="character-img ghost-cyan-char" src="ghost_cyan.png" alt="Cyan Ghost" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
            <div class="character-img ghost-cyan-char" style="display:none;"></div>

            <img class="character-img ghost-orange-char" src="ghost_orange.png" alt="Orange Ghost" onerror="this.style.display='none'; this.nextElementSibling.style.display='block';">
            <div class="character-img ghost-orange-char" style="display:none;"></div>
        </div>

        <button id="startButton">Начать</button>
    </div>
    <!-- --- Конец стартового экрана --- -->
    <canvas id="game"></canvas>
    <div id="controls">
        <div class="btn" id="up">↑</div><br>
        <div class="btn" id="left">←</div>
        <div class="btn" id="down">↓</div>
        <div class="btn" id="right">→</div>
    </div>
    <script>
        // Настройки игры
        const canvas = document.getElementById('game');
        const ctx = canvas.getContext('2d');
        const tileSize = 20;
        const pacmanSpeed = 3;
        const ghostSpeed = 2;
        // --- Инициализация всех аудио ---
        const backgroundMusic = new Audio('background.mp3');
        backgroundMusic.loop = true;
        backgroundMusic.volume = 0.3;
        const dotSound = new Audio('dot.mp3');
        dotSound.volume = 0.5;
        const energizerSound = new Audio('energizer.mp3');
        energizerSound.volume = 0.7;
        const eatGhostSound = new Audio('eat_ghost.mp3');
        eatGhostSound.volume = 0.8;
        const deathSound = new Audio('death.mp3');
        deathSound.volume = 0.8;
        // --- Конец инициализации аудио ---
        // --- Функция для попытки начальной инициализации ВСЕХ звуков ---
        let audioUnlocked = false;
        function unlockAudio() {
            if (audioUnlocked) return Promise.resolve();
            console.log("Попытка разблокировки аудио...");
            const promises = [
                backgroundMusic.play().catch(e => {
                    console.log("Фоновая музыка: play не удался, пытаемся load", e.message);
                    backgroundMusic.load();
                }),
                dotSound.play().then(() => { dotSound.pause(); dotSound.currentTime = 0; }).catch(e => {
                    console.log("Звук точки: play/pause не удался, пытаемся load", e.message);
                    dotSound.load();
                }),
                energizerSound.play().then(() => { energizerSound.pause(); energizerSound.currentTime = 0; }).catch(e => {
                    console.log("Звук энерджайзера: play/pause не удался, пытаемся load", e.message);
                    energizerSound.load();
                }),
                eatGhostSound.play().then(() => { eatGhostSound.pause(); eatGhostSound.currentTime = 0; }).catch(e => {
                    console.log("Звук поедания призрака: play/pause не удался, пытаемся load", e.message);
                    eatGhostSound.load();
                }),
                deathSound.play().then(() => { deathSound.pause(); deathSound.currentTime = 0; }).catch(e => {
                    console.log("Звук смерти: play/pause не удался, пытаемся load", e.message);
                    deathSound.load();
                })
            ];
            return Promise.all(promises)
                .then(() => {
                    audioUnlocked = true;
                    console.log("Аудио успешно разблокировано. Звуки должны работать.");
                    backgroundMusic.play().catch(e => console.log("Не удалось запустить фоновую музыку после разблокировки:", e.message));
                    return true;
                })
                .catch(e => {
                    console.error("Ошибка при разблокировке аудио:", e);
                    audioUnlocked = true; // Даже при ошибке считаем, что попытка была
                    return false;
                });
        }
        // --- Вспомогательная функция для воспроизведения звука ---
        function playSound(sound) {
             if (!audioUnlocked) {
                 console.warn("Попытка воспроизвести звук до разблокировки:", sound.src || sound);
                 return;
             }
             try {
                 sound.currentTime = 0;
                 const playPromise = sound.play();
                 if (playPromise !== undefined) {
                     playPromise.catch(e => console.error("Ошибка воспроизведения звука (" + (sound.src || "unknown") + "):", e));
                 }
             } catch (e) {
                 console.error("Ошибка воспроизведения звука (в catch) (" + (sound.src || "unknown") + "):", e);
             }
        }
        // --- Конец вспомогательной функции ---
        // Подгоняем размер под экран
        function resize() {
            const size = Math.min(window.innerWidth, window.innerHeight - 100);
            canvas.width = 380;
            canvas.height = 420;
            canvas.style.width = size + 'px';
            canvas.style.height = (size * 420/380) + 'px';
        }
        resize();
        window.addEventListener('resize', resize);
        // Лабиринт (1 - стена, 0 - дорога, 2 - точки, 3 - энерджайзер)
        const maze = [
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,3,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,3,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,2,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,1,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,1,1],
            [0,0,0,1,2,1,2,2,2,2,2,2,2,1,2,1,0,0,0],
            [1,1,1,1,2,1,2,1,1,0,1,1,2,1,2,1,1,1,1],
            [2,2,2,2,2,2,2,1,0,0,0,1,2,2,2,2,2,2,2],
            [1,1,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,1,1],
            [0,0,0,1,2,1,2,2,2,2,2,2,2,1,2,1,0,0,0],
            [1,1,1,1,2,1,2,1,1,1,1,1,2,1,2,1,1,1,1],
            [1,2,2,2,2,2,2,2,2,1,2,2,2,2,2,2,2,2,1],
            [1,2,1,1,2,1,1,1,2,1,2,1,1,1,2,1,1,2,1],
            [1,3,2,1,2,2,2,2,2,2,2,2,2,2,2,1,2,3,1],
            [1,1,2,1,2,1,2,1,1,1,1,1,2,1,2,1,2,1,1],
            [1,2,2,2,2,1,2,2,2,1,2,2,2,1,2,2,2,2,1],
            [1,2,1,1,1,1,1,1,2,1,2,1,1,1,1,1,1,2,1],
            [1,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,2,1],
            [1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1]
        ];
        // Игровые объекты
        let pacman = {
            x: 9 * tileSize,
            y: 15 * tileSize,
            dx: 0,
            dy: 0,
            radius: tileSize / 2,
            lives: 3
        };
        // Создаем объекты Image для спрайтов точек
        const dotImage = new Image();
        dotImage.src = 'dot.png';
        const energizerImage = new Image();
        energizerImage.src = 'energizer.png';
        // Создаем объекты Image для Пакмана
        const pacmanImage = new Image();
        pacmanImage.src = 'mypacman.png';
        const pacmanScaredImage = new Image();
        pacmanScaredImage.src = 'mypacman_scared.png';
        const pacmanHealthImage = new Image();
        pacmanHealthImage.src = 'mypacman_health.png';
        // Создаем объекты Image для призраков
        const ghostImages = {
            // Нормальные состояния
            red: new Image(),
            cyan: new Image(),
            orange: new Image(),
            // Испуганные состояния (уникальные для каждого призрака)
            red_scared: new Image(),
            cyan_scared: new Image(),
            orange_scared: new Image()
        };
        // Загружаем изображения
        ghostImages.red.src = 'ghost_red.png';
        ghostImages.cyan.src = 'ghost_cyan.png';
        ghostImages.orange.src = 'ghost_orange.png';
        ghostImages.red_scared.src = 'ghost_red_scared.png';
        ghostImages.cyan_scared.src = 'ghost_cyan_scared.png';
        ghostImages.orange_scared.src = 'ghost_orange_scared.png';
        // Убрали pink призрака, теперь их 3
        let ghosts = [
            { x: 9 * tileSize, y: 8 * tileSize, dx: ghostSpeed, dy: 0, color: 'red', radius: tileSize / 2, imageKey: 'red' },
            { x: 8 * tileSize, y: 9 * tileSize, dx: 0, dy: ghostSpeed, color: 'cyan', radius: tileSize / 2, imageKey: 'cyan' },
            { x: 10 * tileSize, y: 9 * tileSize, dx: 0, dy: -ghostSpeed, color: 'orange', radius: tileSize / 2, imageKey: 'orange' }
        ];
        let dots = [];
        let score = 0;
        let scaredGhosts = false;
        let scaredTimer = 0;
        // Инициализация точек
        function initDots() {
            dots = [];
            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 2) {
                        dots.push({x: x * tileSize + tileSize/2, y: y * tileSize + tileSize/2, big: false});
                    } else if (maze[y][x] === 3) {
                        dots.push({x: x * tileSize + tileSize/2, y: y * tileSize + tileSize/2, big: true});
                    }
                }
            }
        }
        initDots();
        // --- Обработчики управления с вызовом unlockAudio ---
        async function handleUserAction(actionFn) {
            if (!audioUnlocked) {
                await unlockAudio();
            }
            actionFn();
        }
        // Управление с кнопок
        document.getElementById('up').addEventListener('touchstart', () => {
            handleUserAction(() => movePacman(0, -1));
        });
        document.getElementById('down').addEventListener('touchstart', () => {
            handleUserAction(() => movePacman(0, 1));
        });
        document.getElementById('left').addEventListener('touchstart', () => {
            handleUserAction(() => movePacman(-1, 0));
        });
        document.getElementById('right').addEventListener('touchstart', () => {
            handleUserAction(() => movePacman(1, 0));
        });
        // Управление с клавиатуры (для тестирования на ПК)
        document.addEventListener('keydown', (e) => {
            if (e.key === 'ArrowUp') handleUserAction(() => movePacman(0, -1));
            if (e.key === 'ArrowDown') handleUserAction(() => movePacman(0, 1));
            if (e.key === 'ArrowLeft') handleUserAction(() => movePacman(-1, 0));
            if (e.key === 'ArrowRight') handleUserAction(() => movePacman(1, 0));
        });
        // --- Конец обработчиков ---
        function movePacman(dx, dy) {
            pacman.dx = dx * pacmanSpeed;
            pacman.dy = dy * pacmanSpeed;
        }
        // Проверка столкновений со стенами
        function checkCollision(x, y) {
            const tileX = Math.floor(x / tileSize);
            const tileY = Math.floor(y / tileSize);
            if (tileX < 0 || tileY < 0 || tileY >= maze.length || tileX >= maze[tileY].length) {
                return true;
            }
            return maze[tileY][tileX] === 1;
        }
        // Сбор точек
        function collectDots() {
            for (let i = 0; i < dots.length; i++) {
                const dot = dots[i];
                const dist = Math.sqrt(Math.pow(pacman.x - dot.x, 2) + Math.pow(pacman.y - dot.y, 2));
                if (dist < pacman.radius) {
                    score += dot.big ? 50 : 10;
                    if (dot.big) {
                        scaredGhosts = true;
                        scaredTimer = 500;
                        playSound(energizerSound);
                    } else {
                        playSound(dotSound);
                    }
                    dots.splice(i, 1);
                    break;
                }
            }
        }
        // Телепортация через туннели
        function checkTunnels(obj) {
            if (obj.x < -obj.radius) {
                obj.x = canvas.width + obj.radius;
            } else if (obj.x > canvas.width + obj.radius) {
                obj.x = -obj.radius;
            }
        }
        // ИИ призраков
        function updateGhosts() {
            if (scaredTimer > 0) {
                scaredTimer--;
            } else {
                scaredGhosts = false;
            }
            ghosts.forEach(ghost => {
                const directions = [];
                if (!checkCollision(ghost.x, ghost.y - ghostSpeed)) directions.push({dx: 0, dy: -ghostSpeed});
                if (!checkCollision(ghost.x, ghost.y + ghostSpeed)) directions.push({dx: 0, dy: ghostSpeed});
                if (!checkCollision(ghost.x - ghostSpeed, ghost.y)) directions.push({dx: -ghostSpeed, dy: 0});
                if (!checkCollision(ghost.x + ghostSpeed, ghost.y)) directions.push({dx: ghostSpeed, dy: 0});
                if (directions.length > 0 && (Math.random() < 0.05 ||
                    checkCollision(ghost.x + ghost.dx, ghost.y + ghost.dy))) {
                    const newDir = directions[Math.floor(Math.random() * directions.length)];
                    ghost.dx = newDir.dx;
                    ghost.dy = newDir.dy;
                }
                ghost.x += ghost.dx;
                ghost.y += ghost.dy;
                checkTunnels(ghost);
                // Проверка столкновения с Пакманом
                const dist = Math.sqrt(Math.pow(pacman.x - ghost.x, 2) + Math.pow(pacman.y - ghost.y, 2));
                if (dist < pacman.radius + ghost.radius) {
                    if (scaredGhosts) {
                        ghost.x = 9 * tileSize;
                        ghost.y = 8 * tileSize;
                        score += 200;
                        playSound(eatGhostSound);
                    } else {
                        pacman.lives--;
                        playSound(deathSound);
                        resetPositions();
                    }
                }
            });
        }
        function resetPositions() {
            pacman.x = 9 * tileSize;
            pacman.y = 15 * tileSize;
            pacman.dx = 0;
            pacman.dy = 0;
            // Сбрасываем позиции для 3 призраков
            ghosts[0].x = 9 * tileSize; ghosts[0].y = 8 * tileSize;
            ghosts[1].x = 8 * tileSize; ghosts[1].y = 9 * tileSize;
            ghosts[2].x = 10 * tileSize; ghosts[2].y = 9 * tileSize;
        }
        // Главный игровой цикл
        function gameLoop() {
            update();
            draw();
            requestAnimationFrame(gameLoop);
        }
        function update() {
            const newX = pacman.x + pacman.dx;
            const newY = pacman.y + pacman.dy;
            if (!checkCollision(newX, pacman.y)) {
                pacman.x = newX;
            }
            if (!checkCollision(pacman.x, newY)) {
                pacman.y = newY;
            }
            checkTunnels(pacman);
            collectDots();
            updateGhosts();
            if (pacman.lives <= 0) {
                pacman.lives = 3;
                score = 0;
                initDots();
                resetPositions();
            }
            if (dots.length === 0) {
                score = 0;
                initDots();
                resetPositions();
            }
        }
        function draw() {
            ctx.fillStyle = 'black';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            // Рисование лабиринта
            const time = Date.now() * 0.001; // Время в секундах для анимации

            for (let y = 0; y < maze.length; y++) {
                for (let x = 0; x < maze[y].length; x++) {
                    if (maze[y][x] === 1) {
                        // Создаем волновой эффект, зависящий от положения и времени
                        // Используем разные фазы для x и y, чтобы создать диагональные волны
                        const waveX = Math.sin(x * 0.5 + time) * 0.5 + 0.5; // Значение от 0 до 1
                        const waveY = Math.cos(y * 0.3 + time * 1.2) * 0.5 + 0.5; // Значение от 0 до 1
                        const waveTime = Math.sin(time * 0.7) * 0.5 + 0.5; // Глобальная временная волна

                        // Комбинируем волны для получения изменяющегося значения от 0 до 1
                        const combinedWave = (waveX + waveY + waveTime) / 3;

                        // Преобразуем combinedWave (0-1) в компоненты RGB
                        // Это создаст плавный переход между цветами
                        const r = Math.floor(Math.sin(combinedWave * Math.PI * 2 + 0) * 127 + 128);
                        const g = Math.floor(Math.sin(combinedWave * Math.PI * 2 + 2) * 127 + 128);
                        const b = Math.floor(Math.sin(combinedWave * Math.PI * 2 + 4) * 127 + 128);

                        // Устанавливаем цвет для конкретной плитки стены
                        ctx.fillStyle = `rgb(${r}, ${g}, ${b})`;
                        ctx.fillRect(x * tileSize, y * tileSize, tileSize, tileSize);
                    }
                }
            }
            // Рисование точек
            // ctx.fillStyle = 'white'; // Закомментировано, так как рисуем изображения
            for (const dot of dots) {
                // ctx.beginPath(); // Закомментировано, так как рисуем изображения
                // ctx.arc(dot.x, dot.y, dot.big ? 6 : 3, 0, Math.PI * 2); // Закомментировано, так как рисуем изображения
                // ctx.fill(); // Закомментировано, так как рисуем изображения
                // --- Новое отображение точек с помощью изображений ---
                const dotSize = dot.big ? 12 : 6; // Примерный размер из оригинального кода * 2
                const useImage = dot.big ? energizerImage : dotImage;
                if (useImage.complete && useImage.naturalWidth !== 0) {
                    // Рисуем изображение точки или энерджайзера
                    ctx.drawImage(
                        useImage,
                        dot.x - dotSize / 2, // x координата на холсте (левый верхний угол)
                        dot.y - dotSize / 2, // y координата на холсте (левый верхний угол)
                        dotSize,             // ширина на холсте
                        dotSize              // высота на холсте
                    );
                } else {
                    // Резервный вариант: если изображение не загрузилось, рисуем белый круг
                    console.warn(`Изображение ${dot.big ? 'энерджайзера' : 'точки'} не загружено. Используется резервный вариант.`);
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(dot.x, dot.y, dot.big ? 6 : 3, 0, Math.PI * 2);
                    ctx.fill();
                }
                // --- Конец нового отображения точек ---
            }
            // --- Рисование Пакмана из изображения ---
            // Определяем, какое изображение использовать для основного Пакмана
            let usePacmanImage = pacmanImage; // По умолчанию обычное изображение
            if (scaredGhosts) {
                // Если призраки испуганы, используем изображение испуганного Пакмана
                usePacmanImage = pacmanScaredImage;
            }
            if (usePacmanImage.complete && usePacmanImage.naturalWidth !== 0) {
                // Рисуем выбранное изображение Пакмана
                ctx.drawImage(usePacmanImage, pacman.x - pacman.radius, pacman.y - pacman.radius, pacman.radius * 2, pacman.radius * 2);
            } else {
                 // Резервный вариант: рисуем желтый круг
                 console.warn(`Изображение Пакмана (${usePacmanImage.src}) не загружено. Используется резервный вариант.`);
                 ctx.fillStyle = 'yellow';
                 ctx.beginPath();
                 ctx.arc(pacman.x, pacman.y, pacman.radius, 0, Math.PI * 2);
                 ctx.fill();
            }
            // --- Конец рисования Пакмана ---
            // Рисование призраков из изображений
            ghosts.forEach(ghost => {
                // Определяем, какое изображение использовать
                let useImageKey;
                if (scaredGhosts) {
                    // Используем уникальное изображение для испуганного состояния
                    useImageKey = ghost.imageKey + '_scared';
                } else {
                    // Используем обычное изображение
                    useImageKey = ghost.imageKey;
                }
                const useImage = ghostImages[useImageKey];
                if (useImage && useImage.complete && useImage.naturalWidth !== 0) {
                    // Рисуем изображение призрака
                    ctx.drawImage(useImage, ghost.x - ghost.radius, ghost.y - ghost.radius, ghost.radius * 2, ghost.radius * 2);
                } else {
                    // Резервный вариант: рисуем цветной круг
                    console.warn(`Изображение для призрака ${useImageKey} не загружено. Используется резервный вариант.`);
                    ctx.fillStyle = scaredGhosts ? '#0000FF' : ghost.color; // Синий для испуганного, иначе цвет призрака
                    ctx.beginPath();
                    ctx.arc(ghost.x, ghost.y - 5, ghost.radius, Math.PI, 0, false);
                    ctx.lineTo(ghost.x + ghost.radius, ghost.y + ghost.radius - 5);
                    for (let i = 0; i < 3; i++) {
                        ctx.lineTo(ghost.x + ghost.radius - (i * 10), ghost.y + ghost.radius - 5 + (i % 2 === 0 ? 5 : 0));
                    }
                    ctx.lineTo(ghost.x - ghost.radius, ghost.y + ghost.radius - 5);
                    ctx.closePath();
                    ctx.fill();
                    // Рисуем глаза резервного призрака
                    ctx.fillStyle = 'white';
                    ctx.beginPath();
                    ctx.arc(ghost.x - 5, ghost.y - 8, 4, 0, Math.PI * 2);
                    ctx.arc(ghost.x + 5, ghost.y - 8, 4, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath();
                    ctx.arc(ghost.x - 5 + (ghost.dx * 2), ghost.y - 8 + (ghost.dy * 2), 2, 0, Math.PI * 2);
                    ctx.arc(ghost.x + 5 + (ghost.dx * 2), ghost.y - 8 + (ghost.dy * 2), 2, 0, Math.PI * 2);
                    ctx.fill();
                }
            });

                  // --- Рисование жизней (иконок здоровья) в правом верхнем углу ---
            const lifeSize = 20; // Размер иконки жизни (диаметр)
            const lifePadding = 10; // Отступ от края экрана
            const lifeSpacing = 5;  // Расстояние между иконками

            for (let i = 0; i < pacman.lives; i++) {
                // Рассчитываем позицию X для каждой иконки (начиная справа)
                const lifeX = canvas.width - lifePadding - lifeSize - i * (lifeSize + lifeSpacing);
                // Позиция Y для отображения в верхней части экрана
                const lifeY = lifePadding + lifeSize / 2;

                // Проверяем, загружено ли изображение иконки здоровья
                if (pacmanHealthImage.complete && pacmanHealthImage.naturalWidth !== 0) {
                    // Рисуем изображение иконки здоровья
                    ctx.drawImage(
                        pacmanHealthImage,
                        lifeX,               // x координата на холсте (левый верхний угол)
                        lifeY - lifeSize/2,  // y координата на холсте (левый верхний угол)
                        lifeSize,            // ширина на холсте
                        lifeSize             // высота на холсте
                    );
                } else {
                    // Резервный вариант: если изображение не загрузилось, рисуем желтый круг
                    console.warn("Изображение иконки здоровья (mypacman_health.png) не загружено. Используется резервный вариант.");
                    ctx.fillStyle = 'yellow';
                    ctx.beginPath();
                    ctx.arc(lifeX + lifeSize/2, lifeY, lifeSize / 2, 0.2, Math.PI * 2 - 0.2);
                    ctx.lineTo(lifeX + lifeSize/2, lifeY);
                    ctx.fill();
                }
            }
            // --- Конец рисования жизней ---
        }
        // Обработчики загрузки для изображений призраков
        Object.keys(ghostImages).forEach(key => {
            const img = ghostImages[key];
            img.onload = function() {
                console.log(`Изображение призрака ${key} загружено.`);
            };
            img.onerror = function() {
                console.error(`Ошибка загрузки изображения ${key}.png.`);
            };
        });
        // --- Обработчики загрузки для изображений Пакмана ---
        pacmanImage.onload = function() {
            console.log("Изображение Пакмана (mypacman.png) загружено.");
        };
        pacmanImage.onerror = function() {
            console.error("Ошибка загрузки изображения mypacman.png.");
        };
        pacmanScaredImage.onload = function() {
            console.log("Изображение испуганного Пакмана (mypacman_scared.png) загружено.");
        };
        pacmanScaredImage.onerror = function() {
            console.error("Ошибка загрузки изображения mypacman_scared.png.");
        };
        pacmanHealthImage.onload = function() {
            console.log("Изображение иконки здоровья Пакмана (mypacman_health.png) загружено.");
        };
        pacmanHealthImage.onerror = function() {
            console.error("Ошибка загрузки изображения mypacman_health.png.");
        };
        // --- Конец обработчиков загрузки для изображений Пакмана ---
        // --- Обработчики загрузки для изображений точек ---
        dotImage.onload = function() {
            console.log("Изображение точки (dot.png) загружено.");
        };
        dotImage.onerror = function() {
            console.error("Ошибка загрузки изображения dot.png.");
        };
        energizerImage.onload = function() {
            console.log("Изображение энерджайзера (energizer.png) загружено.");
        };
        energizerImage.onerror = function() {
            console.error("Ошибка загрузки изображения energizer.png.");
        };
        // --- Конец обработчиков загрузки для точек ---
        // --- Обработка стартовой кнопки ---
        document.getElementById('startButton').addEventListener('click', async function() {
            console.log("Нажата кнопка 'Начать'");
            // Скрываем стартовый экран
            document.getElementById('startScreen').style.display = 'none';
            // Пытаемся разблокировать аудио
            if (!audioUnlocked) {
                try {
                    await unlockAudio();
                    console.log("Аудио разблокировано по кнопке.");
                } catch (e) {
                    console.error("Ошибка при разблокировке аудио по кнопке:", e);
                }
            } else {
                console.log("Аудио уже было разблокировано ранее.");
            }
            // Принудительно запускаем фоновую музыку, если она еще не играет
            // и если аудио было разблокировано
            if (audioUnlocked) {
                 if (backgroundMusic.paused) {
                     console.log("Принудительный запуск фоновой музыки...");
                     playSound(backgroundMusic); // Используем вашу оберточную функцию
                     // Альтернатива напрямую: backgroundMusic.play().catch(e => console.log("Не удалось принудительно запустить фоновую музыку:", e.message));
                 } else {
                     console.log("Фоновая музыка уже играет.");
                 }
            } else {
                console.warn("Аудио не разблокировано, фоновая музыка не будет запущена.");
            }
        });
        // --- Конец обработки стартовой кнопки ---
        // Запускаем игровой цикл независимо от загрузки изображений
        // Игра начинается, но звуки будут работать только после нажатия кнопки
        gameLoop();
    </script>
</body>
</html>
